package edu.uoc.meteoPocket{	import com.adobe.lighthouse.controls.IItemRenderer;	import com.adobe.lighthouse.controls.TouchStates;	import com.adobe.lighthouse.controls.UIControl;	import com.adobe.lighthouse.util.TextFieldUtil;		import flash.display.MovieClip;	import flash.display.Sprite;	import flash.text.TextField;
		public class ListItem extends UIControl implements IItemRenderer	{		private const MARGIN:int = 20;				private static const PADDING_LEFT_RIGHT:Number = 12;		private static const PADDING_TOP_BOTTOM:Number = 16;				/**		 * The background colors for the various states.		 */		// As no action is needed for our application, no need to change color		// However I let the possibility if future versions need it		private static const UP_COLOR:Number = 0x060A0B;		private static const DOWN_COLOR:Number = 0x060A0B;		private static const SELECTED_COLOR:Number = 0x060A0B;			private var _data:Object;		private var _selected:Boolean;		private var color:Number;		private var bgAlpha:Number = .6;						//Elements a la timeline de ListItem		public var weatherIcon_sp:MovieClip;		public var dia_tf:TextField;		public var condicions_tf:TextField;		public var tempHigh_tf:TextField;		public var tempLow_tf:TextField;		public var vLineLeft_sp:Sprite;		public var vLineRight_sp:Sprite;						public function ListItem() 		{			super();			init();		}				private function init(): void 		{			mouseChildren = false;			cacheAsBitmap = true;		}				public function set data(value:Object):void		{			if (value) {				_data = value;				// Invalidate so new layout is reflected based on the text.				invalidateDisplayList(this);			}			else			{				dia_tf.text = "No data";			}		}				public function get data():Object		{			return _data;		}				override protected function updateDisplayList(width:Number, height:Number):void		{			//scaling elements			var scale = Math.max(stage.stageWidth,stage.stageHeight)/800;						weatherIcon_sp.scaleX = scale;			weatherIcon_sp.scaleY = scale;			dia_tf.scaleX = scale;			dia_tf.scaleY = scale;			condicions_tf.scaleX = scale;			condicions_tf.scaleY = scale;			tempHigh_tf.scaleX = scale;			tempHigh_tf.scaleY = scale;			tempLow_tf.scaleX = scale;			tempLow_tf.scaleY = scale;									// Repositionning elements			weatherIcon_sp.x = MARGIN*scale;			vLineLeft_sp.x = weatherIcon_sp.x + weatherIcon_sp.width + MARGIN*scale;			dia_tf.x = vLineLeft_sp.x + MARGIN*scale;			condicions_tf.x = vLineLeft_sp.x + MARGIN*scale;						condicions_tf.y = dia_tf.y + dia_tf.height -20*scale;			tempLow_tf.y = tempHigh_tf.y + tempHigh_tf.height -5*scale;			vLineLeft_sp.y = weatherIcon_sp.height/2;			vLineRight_sp.y = weatherIcon_sp.height/2;						tempHigh_tf.x = stage.stageWidth - tempHigh_tf.width - scale*MARGIN;			tempLow_tf.x = stage.stageWidth - tempLow_tf.width - scale*MARGIN;			vLineRight_sp.x = tempHigh_tf.x - scale*MARGIN;						// Update data (first time)			if (_data)			{				// Use the existing color for the graphics.				drawGraphics(color);				//recuperem les dades				dia_tf.text = _data.dia;				condicions_tf.text = _data.condicions;				tempHigh_tf.text = _data.tempHigh;				tempLow_tf.text = _data.tempLow;								// Weather Picto				trace("Weather dia: " + _data.dia + "code:" +_data.code);				if( _data.code <=47) {					weatherIcon_sp.gotoAndStop(_data.code+1);				} else {					weatherIcon_sp.gotoAndStop("notAvailable");				}							}					}				public function set selected(value:Boolean):void		{			drawGraphics(value ? SELECTED_COLOR : UP_COLOR);			_selected = value;		}				/**		 * Sets the state for either up or down.		 */		public function set state(value:String):void		{			if (!_selected) { drawGraphics(value == TouchStates.DOWN ? DOWN_COLOR : UP_COLOR); }		}				/**		 * Draws the background graphics.		 */		private function drawGraphics(color:Number):void		{			this.color = color;			graphics.clear();			graphics.beginFill(color, bgAlpha);			graphics.drawRect(0, 0, width, height);			graphics.lineStyle(1, 0x2E4750);			graphics.moveTo(0, height - 1);			graphics.lineTo(width, height - 1);		}	}}