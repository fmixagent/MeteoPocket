package edu.uoc.meteoPocket{	import com.adobe.lighthouse.controls.DraggableVerticalList;	import com.adobe.lighthouse.events.HorizontalSwipeEvent;	import com.adobe.lighthouse.util.FrameDelayedCall;	import com.greensock.TweenMax;		import edu.uoc.meteoPocket.ListItem;	import edu.uoc.meteoPocket.Screen;	import edu.uoc.meteoPocket.ScreenEvent;	import edu.uoc.meteoPocket.ScreenTypes;		import flash.display.SimpleButton;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.text.TextField;
		public class ScreenB extends Screen	{		// Constants		private const MARGIN:int = 30;		private const DURATION_TRANSITION:Number = 0.5;				// Timeline instances		public var title_tf:TextField;		public var city_tf:TextField;		public var btToday_sp:SimpleButton;		public var background_sp:Sprite;		public var listContainer_sp:Sprite;				// Private variables		private var _weatherData:Object;		private var scale:Number;				// Scrollable list		private var _draggableList:DraggableVerticalList;		private var _optionList:Array;						public function ScreenB(title:String,weatherData:Object)		{			super();						// Recover data			title_tf.text = title;			_weatherData = new Object();			_weatherData = weatherData;		}				protected override function init(ev:Event):void 		{									// Today weather button			btToday_sp.addEventListener(MouseEvent.CLICK, gotoTodayScreen);						// Initialise information			city_tf.text = "a " +_weatherData.city;						// Scale list item depending on screen resolution			var listItemHeight = 80*Math.max(stage.stageWidth,stage.stageHeight)/800;						// Initialise scrollable list (package com.adobe.lightghouse)			_draggableList = new DraggableVerticalList(listItemHeight,		// The height of each item.												  ListItem,		// The renderer class to use for each item.												  0xff0000,		// The background color of each item.												  0,			// The background color alpha of each item.												  false,	    // Indicates whether or not to dispatch horizontal events. Used when horizontal swipe events need to be detected.												  0,			// The offset between the first item and the top edge.												  20,			// The padding between the top edge and the scrollbar.												  20);			// The padding between the bottom edge and the scrollbar.					_draggableList.y = title_tf.y + title_tf.height + MARGIN;			_draggableList.width = stage.stageWidth;			_draggableList.height = stage.stageHeight - _draggableList.y - 100;			_draggableList.addEventListener(Event.CHANGE, changeHandler);			listContainer_sp.addChild(_draggableList);						// Array of objects			// each object will have the data for each listItem 			_optionList = new Array();			for (var i:Number = 0; i<7 ; i++){				_optionList[i] = {					dia: _weatherData.forecastDay[i] + " " +  _weatherData.forecastDate[i], 					condicions: _weatherData.forecastCondition[i], 					tempHigh: _weatherData.forecastHigh[i] + " ºC",					tempLow: _weatherData.forecastLow[i] + " ºC",					code: _weatherData.forecastCode[i]};			}							_draggableList.dataProvider = _optionList;						// Add a handler for keyDown which is dispatched when a			// user scrolls the scroll wheel on an Android device.			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);						super.init(ev);		}				private function keyDownHandler(e:KeyboardEvent):void		{			// Listen for 38 and 40 which corresponds to scrolling up and down on an Android scrollWheel.			if (e.keyCode == 38 || e.keyCode == 40)			{				// 38 = up, 40 = down				var deltaScrollY:Number = e.keyCode == 38 ? -100 : 100;				_draggableList.tweenScrollYTo(_draggableList.scrollY + deltaScrollY);			}		}				/**		 * Handler for when a user clicks an item in draggableList.		 */		private function changeHandler(e:Event):void		{			// If needed we can recover the information of the clicked item			//var o:Object = _draggableList.selectedItem;			//trace(o.dia, o.temperatura); 		}				private function gotoTodayScreen(ev:MouseEvent):void 		{			var e:ScreenEvent = new ScreenEvent(ScreenEvent.CHANGE_SCREEN, false, false, ScreenTypes.SCREEN_A);			dispatchEvent(e);		}				public override function screenIn():void 		{						this.x = this.width;			this.alpha = 0;			var tween:TweenMax = new TweenMax(this,DURATION_TRANSITION, {x:0,alpha:1});					}				public override function screenOut():void 		{			var tween:TweenMax = new TweenMax(this,DURATION_TRANSITION, {x:this.width,alpha:0,onComplete:function(){Main(root).removeOut()}});		}				protected override function adaptLayout(ev:Event = null):void 		{			var top = Main(root).topBar_sp.height;			scale = Math.max(stage.stageWidth,stage.stageHeight)/800;						// Positionning of the elements that doesn't change from landscape or portrait mode						// Scale elements			btToday_sp.scaleX = scale;			btToday_sp.scaleY = scale;			title_tf.scaleX = scale;			title_tf.scaleY = scale;			city_tf.scaleX = scale;			city_tf.scaleY = scale;						// title_tf : screen title			title_tf.x = stage.stageWidth/2 - title_tf.width/2;			title_tf.y = top + MARGIN*scale;						//City			city_tf.x = stage.stageWidth/2 - city_tf.width/2;			city_tf.y = title_tf.y + title_tf.height - 10*scale;						// btWeek_sp : button to weekly pronostic			btToday_sp.x = Math.floor((stage.stageWidth - btToday_sp.width)/2);			btToday_sp.y = stage.stageHeight - btToday_sp.height - MARGIN*scale;						// detail text position and width			_draggableList.y = city_tf.y + city_tf.height+ 8;			_draggableList.width = stage.stageWidth;			_draggableList.height = btToday_sp.y - _draggableList.y - MARGIN;					// background			background_sp.width = stage.stageWidth;			background_sp.height = stage.stageHeight;		}	}}